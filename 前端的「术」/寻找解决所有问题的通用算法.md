#! https://zhuanlan.zhihu.com/p/531142837
# 寻找解决所有问题的通用算法

> 旧文重发，从侧面解释了[为什么目前全场景无代码方案不可行](https://zhuanlan.zhihu.com/p/459375469)。


这是个如此诱人的想法，可能很多人都有过。

遇到 P, NP, NPC 的概念后，发现我要寻找的通用算法，其实就是一个 NPC 问题算法，指数级复杂度。而这个结果并不是我想要的。
虽然这个想法似乎是个陷阱，但过程中，学到了不少有意思的东西。

## 约化

通俗的说，把一个问题 A 转化为另一个问题 B，这样问题 B 的算法就能用来求解 A。举个例子，求解一个一元一次方程和求解一个一元二次方程。前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。也可以说，一元一次方程是一元二次方程二次项系数为零的特殊情况。
于是，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。
就是这个过程，所有多项式复杂度的 P 问题都可以约化为 NP 问题，所有的 NP 问题都可以约化为 NPC 问题。虽然一个 P 问题使用 NPC 算法求解是没意义的。但给了我们另一个启发。

## 举一反三的方法

算法题千变万化，如何会一道，能解一类题呢。约化或等价转化，对问题换一种描述方式。
O(1) 复杂度的往往可以规约到 O(logN) 或 0(N) 复杂度的问题并加上一些额外的约束。比如一类动态规划问题都可以转化为 DAG 上的某个问题。

## 近似解

尤其发生在 NP问题中，获得精确解的成本太高，可以放弃些许精确获得效率的大幅提升。有名的红黑树可以当做例子，放弃了绝对平衡，提高了树调整效率（当然还有用改色代替改链接带来的高效）。前端 VNode diff 也是很好的例子。

## P = NP

NPC 问题有可能转化为 P 问题吗，觉的可以映射到我下面的证明，得到 P != NP。

## 不会存在一个算法，在所有情况下都是最高效的

反证如下：假设存在一个在所有情况下都是最高效的算法， 那么 A限定下该算法是最高效的。现在在 A 限定基础上增加限定 B，使得算法中一个操作变的不必要，那么在 A + B 限定下，必然存在一个更高效的算法。和假定矛盾，故不会存在一个算法，在所有情况下高效。
其实从信息的角度，这个命题很直觉：随着影响问题求解的信息增多，意味着，你可以进行更多的剪枝，通用算法中的很多操作可以被砍掉，从而变得更高效。
从该命题得到的一个推论：高效和通用不可兼得。
这也可以回答很多人的一个疑问：为什么排序算法这么多？ 因为它们分别分别适用不同的情景（限定条件）。 关键是识别当前的情景，选择相对恰当的排序算法。 当然，（除非你在开发通用库函数）多数情况下适应当前情景的最高效算法压根没发明。因为列举的这些排序算法，每个都适合一类场景，业务中，你的场景往往更具体。这时就要根据具体情景调教这些通用算法了，有时候甚至需要换个思路重写。无论如何，你都能从前辈的智慧中，找到滋养。

先让大师们智慧的光芒照亮一部分漆黑，看到他们能看到的东西，才能比前辈看的更远。
